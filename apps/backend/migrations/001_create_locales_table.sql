-- ============================================================
-- Migration 001: Localesテーブル作成
-- ============================================================
-- 目的: 多言語対応の基礎となる言語情報を管理
-- 作成日: 2026-02-10
-- ============================================================

-- ============================================================
-- 💡 このテーブルの役割
-- ============================================================
-- Localesテーブルは、ブログでサポートする言語（日本語、英語など）を
-- 管理する基礎テーブルです。
--
-- 例:
-- - 日本語 (ja)
-- - 英語 (en)
-- - 中国語 (zh)
-- - 韓国語 (ko)
--
-- 他の多くのテーブルが、このテーブルを参照して多言語対応を実現します。
-- ============================================================

-- ============================================================
-- テーブル定義
-- ============================================================
CREATE TABLE locales (
    -- --------------------------------------------------------
    -- 主キー: locale_id
    -- --------------------------------------------------------
    -- SERIAL = 自動採番される整数型（1, 2, 3, ...）
    -- PRIMARY KEY = このカラムがテーブルの主キー（一意の識別子）
    -- 
    -- 💡 なぜSERIAL?
    -- - 自動的に番号が振られるので、手動で管理する必要がない
    -- - 他のテーブルから参照する際に使用（外部キー）
    locale_id           SERIAL PRIMARY KEY,
    
    -- --------------------------------------------------------
    -- 言語コード: code
    -- --------------------------------------------------------
    -- VARCHAR(10) = 最大10文字の可変長文字列
    -- UNIQUE = 重複を許さない（同じ言語コードは1つだけ）
    -- NOT NULL = 必須項目（NULLを許さない）
    --
    -- 💡 格納される値の例:
    -- - 'ja' (日本語)
    -- - 'en' (英語)
    -- - 'zh' (中国語)
    -- - 'ko' (韓国語)
    --
    -- 💡 なぜUNIQUE?
    -- - 同じ言語コードが複数あると混乱するため
    -- - 例: 'ja'が2つあったらどちらが正しい日本語かわからない
    code                VARCHAR(10) UNIQUE NOT NULL,
    
    -- --------------------------------------------------------
    -- 言語名: name
    -- --------------------------------------------------------
    -- VARCHAR(100) = 最大100文字の可変長文字列
    -- NOT NULL = 必須項目
    --
    -- 💡 格納される値の例:
    -- - 'Japanese' (日本語の英語表記)
    -- - 'English' (英語の英語表記)
    -- - '日本語' (日本語の日本語表記)
    --
    -- 💡 なぜ必要?
    -- - 管理画面で表示する際に、人間が読みやすい名前が必要
    -- - 'ja'だけだとわかりにくいが、'Japanese'ならわかりやすい
    name                VARCHAR(100) NOT NULL,
    
    -- --------------------------------------------------------
    -- デフォルト言語フラグ: is_default
    -- --------------------------------------------------------
    -- BOOLEAN = 真偽値（trueまたはfalse）
    -- DEFAULT FALSE = 初期値はfalse
    -- NOT NULL = 必須項目
    --
    -- 💡 用途:
    -- - ブログのデフォルト言語を指定
    -- - 通常、1つの言語だけがtrue（例: 日本語ブログなら'ja'がtrue）
    --
    -- 💡 使用例:
    -- - ユーザーが言語を指定しない場合、この言語で表示
    -- - URLに言語コードがない場合、この言語にリダイレクト
    is_default          BOOLEAN DEFAULT FALSE NOT NULL,
    
    -- --------------------------------------------------------
    -- 有効/無効フラグ: is_active
    -- --------------------------------------------------------
    -- BOOLEAN = 真偽値（trueまたはfalse）
    -- DEFAULT TRUE = 初期値はtrue
    -- NOT NULL = 必須項目
    --
    -- 💡 用途:
    -- - 一時的に言語を無効化したい場合に使用
    -- - 例: 中国語版を準備中の場合、is_active=falseにする
    --
    -- 💡 削除ではなく無効化する理由:
    -- - 過去のデータとの整合性を保つため
    -- - 将来再度有効化する可能性があるため
    is_active           BOOLEAN DEFAULT TRUE NOT NULL,
    
    -- --------------------------------------------------------
    -- 作成日時: created_at
    -- --------------------------------------------------------
    -- TIMESTAMP WITH TIME ZONE = タイムゾーン付き日時型
    -- DEFAULT NOW() = 初期値は現在日時
    -- NOT NULL = 必須項目
    --
    -- 💡 なぜタイムゾーン付き?
    -- - 世界中のユーザーが使う可能性があるため
    -- - サーバーのタイムゾーンに依存せず、正確な時刻を記録
    --
    -- 💡 格納される値の例:
    -- - '2026-02-10 10:30:00+09:00' (日本時間)
    -- - '2026-02-10 01:30:00+00:00' (UTC時間)
    created_at          TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- ============================================================
-- インデックス作成
-- ============================================================
-- インデックスとは?
-- - 本の索引のようなもの
-- - データを高速に検索するための仕組み
--
-- 💡 なぜインデックスが必要?
-- - WHERE code = 'ja' のような検索を高速化
-- - インデックスがないと、全行を順番に調べる必要がある（遅い）
-- - インデックスがあると、直接目的のデータにアクセスできる（速い）
-- ============================================================

-- codeカラムにインデックスを作成
-- 💡 なぜcodeにインデックス?
-- - APIで 'ja' や 'en' を指定して検索することが多いため
-- - 例: SELECT * FROM locales WHERE code = 'ja'
CREATE INDEX idx_locales_code ON locales(code);

-- is_activeカラムにインデックスを作成
-- 💡 なぜis_activeにインデックス?
-- - 有効な言語だけを取得する検索が多いため
-- - 例: SELECT * FROM locales WHERE is_active = TRUE
CREATE INDEX idx_locales_is_active ON locales(is_active);

-- ============================================================
-- テーブルとカラムにコメントを追加
-- ============================================================
-- PostgreSQLの機能で、テーブルやカラムに説明を付けられる
-- 💡 なぜコメント?
-- - データベースを見た人が、すぐに理解できる
-- - ドキュメントとしても機能する
-- ============================================================

COMMENT ON TABLE locales IS 
'多言語対応の基礎テーブル: ブログでサポートする言語情報を管理';

COMMENT ON COLUMN locales.locale_id IS 
'ロケールID（主キー、自動採番）';

COMMENT ON COLUMN locales.code IS 
'言語コード（ISO 639-1形式: ja, en, zh, ko など）';

COMMENT ON COLUMN locales.name IS 
'言語名（表示用: Japanese, English, 日本語 など）';

COMMENT ON COLUMN locales.is_default IS 
'デフォルト言語フラグ（通常1つの言語のみtrue）';

COMMENT ON COLUMN locales.is_active IS 
'有効/無効フラグ（falseの場合、この言語は使用不可）';

COMMENT ON COLUMN locales.created_at IS 
'作成日時（タイムゾーン付き）';

-- ============================================================
-- 💡 SQL用語解説
-- ============================================================
--
-- CREATE TABLE
--   → 新しいテーブルを作成するSQL文
--
-- SERIAL
--   → 自動採番される整数型（PostgreSQL固有）
--   → 1, 2, 3, ... と自動的に番号が振られる
--
-- PRIMARY KEY
--   → 主キー（テーブル内で一意の識別子）
--   → 重複不可、NULL不可
--
-- VARCHAR(n)
--   → 可変長文字列型（最大n文字）
--   → 例: VARCHAR(10)は最大10文字まで
--
-- UNIQUE
--   → 一意制約（重複を許さない）
--   → 例: emailやusernameなど、重複してはいけないデータに使用
--
-- NOT NULL
--   → NULL不可制約（必須項目）
--   → 値が必ず入っている必要がある
--
-- BOOLEAN
--   → 真偽値型（trueまたはfalse）
--
-- DEFAULT
--   → デフォルト値（初期値）
--   → 値を指定しなかった場合に自動的に設定される
--
-- TIMESTAMP WITH TIME ZONE
--   → タイムゾーン付き日時型
--   → 世界中どこからアクセスしても正確な時刻を記録
--
-- NOW()
--   → 現在日時を返す関数
--
-- CREATE INDEX
--   → インデックスを作成するSQL文
--   → 検索を高速化する
--
-- COMMENT ON
--   → テーブルやカラムに説明を付けるSQL文
--   → ドキュメント代わりになる
--
-- ============================================================
-- 💡 次のステップ
-- ============================================================
-- 1. このSQLを実行してテーブルを作成
-- 2. サンプルデータを挿入
-- 3. Rustでこのテーブルにアクセスするコードを作成
-- 4. APIエンドポイントを実装
-- ============================================================
